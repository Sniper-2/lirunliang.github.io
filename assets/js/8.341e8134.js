(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{514:function(_,v,t){_.exports=t.p+"assets/img/process.f5b8c4d0.png"},533:function(_,v,t){"use strict";t.r(v);var s=t(33),a=Object(s.a)({},(function(){var _=this,v=_.$createElement,s=_._self._c||v;return s("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[s("h3",{attrs:{id:"js事件循环（浏览器方面）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js事件循环（浏览器方面）"}},[_._v("#")]),_._v(" JS事件循环（浏览器方面）")]),_._v(" "),s("h4",{attrs:{id:"进程跟线程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#进程跟线程"}},[_._v("#")]),_._v(" 进程跟线程")]),_._v(" "),s("ul",[s("li",[s("p",[_._v("进程"),s("br"),_._v("\n进程是系统分配的独立资源，是 CPU 资源分配的基本单位，进程是由一个或者多个线程组成的，当我们打开谷歌浏览器的时候，CPU会给我们创建一个进程，当我们在谷歌浏览器中打开一个tab标签的时候，CPU会在谷歌浏览器这个进程里面为我们创建一个子进程；")]),_._v(" "),s("p",[s("strong",[_._v("如下")]),_._v(" "),s("img",{attrs:{src:t(514),alt:"An image"}})])]),_._v(" "),s("li",[s("p",[_._v("线程\n在一个进程或者子进程里面，会拥有一个或者多个线程，在同一个进程里面的多个线程是共享该进程的资源的；")])]),_._v(" "),s("li",[s("p",[_._v("浏览器中的线程\n当我们在谷歌浏览器中打开一个tab，里面最基本的会包含一下几个线程:")]),_._v(" "),s("ul",[s("li",[s("p",[s("strong",[_._v("GUI 渲染线程")])]),_._v(" "),s("ul",[s("li",[_._v("负责渲染页面，解析 HTML，CSS 构成 DOM 树等，当页面重绘或者由于某种操作引起回流都会调起该线程。")]),_._v(" "),s("li",[_._v("和 JS 引擎线程是互斥的，当 JS 引擎线程在工作的时候，GUI 渲染线程会被挂起，GUI 更新被放入在 JS 任务队列中，等待 JS 引擎线程空闲的时候继续执行。")])])]),_._v(" "),s("li",[s("p",[s("strong",[_._v("JS 引擎线程")])]),_._v(" "),s("ul",[s("li",[_._v("单线程工作，负责解析运行 JavaScript 脚本。")]),_._v(" "),s("li",[_._v("和 GUI 渲染线程互斥，JS 运行耗时过长就会导致页面阻塞。")])])]),_._v(" "),s("li",[s("p",[s("strong",[_._v("事件触发线程")])]),_._v(" "),s("ul",[s("li",[_._v("当事件符合触发条件被触发时，该线程会把对应的事件回调函数添加到任务队列的队尾，等待 JS 引擎处理。如果当前的事件循环已经结束，会以该事件触发的函数作为一个新的事件循环，进行代码的执行")])])]),_._v(" "),s("li",[s("p",[s("strong",[_._v("定时器触发线程")])]),_._v(" "),s("ul",[s("li",[_._v("浏览器定时计数器并不是由 JS 引擎计数的，阻塞会导致计时不准确。")]),_._v(" "),s("li",[_._v("开启定时器触发线程来计时并触发计时，计时完成后会被添加到任务队列中，等待 JS 引擎处理")])])]),_._v(" "),s("li",[s("p",[s("strong",[_._v("http 请求线程")])]),_._v(" "),s("ul",[s("li",[_._v("http 请求的时候会开启一条请求线程。")]),_._v(" "),s("li",[_._v("请求完成有结果了之后，将请求的回调函数添加到任务队列中，等待 JS 引擎处理。")])])])])])]),_._v(" "),s("h4",{attrs:{id:"_1-js是单线程语言"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-js是单线程语言"}},[_._v("#")]),_._v(" 1. JS是单线程语言")]),_._v(" "),s("p",[_._v("当初JS被设计出来是被使用在浏览器中的，如果说JS拥有多个线程，那么当线程A对界面的一个id为test的DOM元素进行操作，而同时又有线程B也对id为test的DOM元素进行操作，就会产生混乱。"),s("br"),_._v("\n所以这也是JS被设计为单线程的原因。")]),_._v(" "),s("h4",{attrs:{id:"_2-js的异步"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-js的异步"}},[_._v("#")]),_._v(" 2. JS的异步")]),_._v(" "),s("p",[_._v("既然我们知道JS是单线程的，但浏览器在执行代码的时候，可能某一行代码或者某一个请求处理时间比较长，那么JS的整个主线程会因为在等待结果返回而导致被卡死，界面将会展示错乱或者空白，这样用户体验肯定是及其的不好，也让JS没有存在的意义，所以JS需要有异步来处理解析时间长或者需要等待的代码，从而不会导致主线程被阻塞卡死；")]),_._v(" "),s("p",[_._v("JS的执行机制实际上是通过事件循环来进行控制执行的，正因为有了事件循环，所以JS才有了异步操作。")]),_._v(" "),s("p",[_._v("JS的异步操作就是通过事件循环来实现的。")]),_._v(" "),s("p",[_._v("事件循环会在一个事件循环的周期内，把回调函数统统放进去一个任务队列中，当宏任务的代码执行完毕之后就会执行任务队列中的回调，达到异步的目的。")]),_._v(" "),s("h4",{attrs:{id:"_4-事件循环"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-事件循环"}},[_._v("#")]),_._v(" 4.事件循环")]),_._v(" "),s("ul",[s("li",[s("p",[_._v("JS调用栈")]),_._v(" "),s("ul",[s("li",[_._v("JS 调用栈是一种后进先出的数据结构。当函数被调用时，会被添加到栈中的顶部，执行完成之后就从栈顶部移出该函数，直到栈内被清空。")]),_._v(" "),s("li",[_._v("调用栈也是追踪函数执行流的一种机制，上下文的绑定跟变量的作用域都是在调用栈中确定的。")])])]),_._v(" "),s("li",[s("p",[_._v("同步任务、异步任务")]),_._v(" "),s("ul",[s("li",[_._v("JavaScript 单线程中的任务分为同步任务和异步任务。同步任务会在调用栈中按照顺序排队等待主线程执行，异步任务则会在异步有了结果后将注册的回调函数添加到任务队列(消息队列)中等待主线程空闲的时候，也就是栈内被清空的时候，被读取到栈中等待主线程执行。任务队列是先进先出的数据结构。")])])]),_._v(" "),s("li",[s("p",[_._v("事件循环")]),_._v(" "),s("ul",[s("li",[_._v("调用栈中的同步任务都执行完毕，栈内被清空了，就代表主线程空闲了，这个时候就会去任务队列中按照顺序读取一个任务放入到栈中执行。每次栈内被清空，都会去读取任务队列有没有任务，有就读取执行，一直循环读取-执行的操作，就形成了事件循环。")])])])])])}),[],!1,null,null,null);v.default=a.exports}}]);