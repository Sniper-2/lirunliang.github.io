(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{539:function(e,t,v){"use strict";v.r(t);var r=v(33),_=Object(r.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h3",{attrs:{id:"vue响应式原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue响应式原理"}},[e._v("#")]),e._v(" Vue响应式原理")]),e._v(" "),v("h4",{attrs:{id:"一-响应式（双向绑定）基本原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一-响应式（双向绑定）基本原理"}},[e._v("#")]),e._v(" 一.响应式（双向绑定）基本原理")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("Vue通过对象原型链上的原生方法"),v("code",[e._v("defineProperty")]),e._v("或"),v("code",[e._v("Proxy")]),e._v("对象进行数据劫持，在我们访问或者修改某个对象的某个属性的时候，通过一段代码进行拦截，然后进行额外的操作")])]),e._v(" "),v("li",[v("p",[e._v("比如我们更新Vue实例里面的data的某个属性时，就会触发"),v("code",[e._v("defineProperty")]),e._v("里面的"),v("code",[e._v("set")]),e._v("方法或"),v("code",[e._v("Proxy")]),e._v("对象里面的"),v("code",[e._v("set")]),e._v("方法，那么我们就可以在这个方法里面进行虚拟DOM树的更新以及HTML界面真实DOM的树的替换，实现了基本的双向绑定了;")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("Object.defineProperty")]),e._v("或"),v("code",[e._v("Proxy")]),e._v("都是需要人为手动去进行getter/setter，为Vue实例里面data选项里面每个属性接入vue实现的代理中间层，以实现双向绑定；")])]),e._v(" "),v("li",[v("p",[e._v("每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。")])])]),e._v(" "),v("h4",{attrs:{id:"二-vue的观察者（监听器）observer"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二-vue的观察者（监听器）observer"}},[e._v("#")]),e._v(" 二.vue的观察者（监听器）Observer")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("vue的Observer类会对vue实例上面的data对象"),v("code",[e._v("（walk方法）")]),e._v("进行递归遍历，包括子属性对象的属性，利用 Object.defineProperty() 进行数据劫持，对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值或改变值，就会触发 setter，那么就能监听到了数据变化。")])]),e._v(" "),v("li",[v("p",[e._v("observer对一个data选项里面某个属性或对象进行数据劫持之后会绑定在其ob属性上，防止重复绑定")])]),e._v(" "),v("li",[v("p",[e._v("如果data选项上面的数据有多层嵌套，那么在Observer进行初始化数据劫持会递归多层，一次性的计算量较大；")])]),e._v(" "),v("li",[v("p",[e._v("无法监听动态新增的属性/删除属性，需要调用Vue.set或Vue.delete或对这个对象进行拷贝，将更新后的新的指针地址指向这个对象对应的属性上；")])]),e._v(" "),v("li",[v("p",[e._v("无法监听数组的变化，需要特殊处理")])])]),e._v(" "),v("h4",{attrs:{id:"三-vue对数据的双向绑定进行特殊处理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三-vue对数据的双向绑定进行特殊处理"}},[e._v("#")]),e._v(" 三.vue对数据的双向绑定进行特殊处理")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("Observer函数里面的"),v("code",[e._v("Object.defineProperty")]),e._v("是对vue实例里面的data对象属性进行双向绑定的，这种实现主要是针对key/value形式的对象，对数组中某个元素变化是无能为力的，所以vue对数组的原型上的操作数组的方式进行拓展；")])]),e._v(" "),v("li",[v("p",[e._v("对数组原型链上面的方法进行是拓展并不会改变原型链上面原本的方法的，拓展的方法是先拷贝（Object.create）原型链上面的方法再进行拓展的；")])]),e._v(" "),v("li",[v("p",[e._v("数组拓展的方法有push,pop,shift,unshift,splice,reverse,sort，这样的话，当我们调用数组的这七个方法其中一个，那么Vue就会感知到，并重新更新界面；")])])])])}),[],!1,null,null,null);t.default=_.exports}}]);